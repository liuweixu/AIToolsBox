import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _objectSpread from "@babel/runtime/helpers/esm/objectSpread2";
import _regeneratorRuntime from "@babel/runtime/helpers/esm/regeneratorRuntime";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import { LOADING_FLAT } from "../const/message";
import { DEFAULT_AVATAR, DEFAULT_USER_AVATAR } from "../const/meta";
import { processSSE } from "../utils/fetch";
import { genUUID } from "../utils/uuid";
import { useMergedState } from 'rc-util';
import { useCallback, useEffect, useMemo, useRef } from 'react';
import { useRefFunction } from "./useRefFunction";
export var initialModelConfig = {
  historyCount: 1,
  model: 'gpt-3.5-turbo',
  params: {
    frequency_penalty: 0,
    presence_penalty: 0,
    temperature: 0.6,
    top_p: 1
  },
  systemRole: ''
};
export var initialState = {
  userProfile: {
    user: {
      avatar: DEFAULT_USER_AVATAR
    },
    assistant: {
      avatar: DEFAULT_AVATAR
    }
  },
  config: initialModelConfig
};

/**
 * Props for the ProChatUIUseListChat component.
 */

/**
 * Custom hook for managing a chat list.
 * @param props - The hook's configuration options.
 * @returns An object containing the chat list, loading state, and various functions to interact with the chat list.
 */
export var useChatList = function useChatList(props) {
  var controller = useRef(null);
  var chatListRef = useRef([]);
  /**
   * Custom hook for managing the chat list.
   *
   * @template T - The type of the chat message content.
   * @param {Object} props - The hook props.
   * @param {ChatMessage<T>[]} props.chatList - The initial chat list.
   * @param {ChatMessage<T>[]} props.initialChatList - The default chat list.
   * @param {Function} props.onChatsChange - The callback function to handle chat list changes.
   * @returns {ChatMessage<T>[]} The chat list and the function to update it.
   */
  var _useMergedState = useMergedState([], {
      value: props.chatList,
      defaultValue: props.initialChatList,
      onChange: function () {
        var _onChange = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(value) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!(props !== null && props !== void 0 && props.onChatsChange)) {
                  _context.next = 3;
                  break;
                }
                _context.next = 3;
                return props === null || props === void 0 ? void 0 : props.onChatsChange(value);
              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function onChange(_x) {
          return _onChange.apply(this, arguments);
        }
        return onChange;
      }(),
      postState: function postState(value) {
        chatListRef.current = value;
        return value;
      }
    }),
    _useMergedState2 = _slicedToArray(_useMergedState, 2),
    chatList = _useMergedState2[0],
    setChatList = _useMergedState2[1];
  var setMessageItem = useRefFunction(function (id, content) {
    var newChatList = chatList.map(function (item) {
      if (item.id === id) {
        return _objectSpread(_objectSpread({}, item), content);
      }
      return item;
    });
    setChatList(newChatList);
  });
  var _useMergedState3 = useMergedState(true, {
      value: props.loading
    }),
    _useMergedState4 = _slicedToArray(_useMergedState3, 2),
    loading = _useMergedState4[0],
    setLoading = _useMergedState4[1];
  var _useMergedState5 = useMergedState(false),
    _useMergedState6 = _slicedToArray(_useMergedState5, 2),
    isLoadingMessage = _useMergedState6[0],
    setIsLoadingMessage = _useMergedState6[1];

  /**
   * Fetches the chat list using the provided request function.
   * If the request function is not provided, it sets the loading state to false and returns.
   * Sets the loading state to true before making the request and sets it to false after the request is completed.
   * If an error occurs during the request, logs the error to the console.
   */
  var fetchChatList = useRefFunction( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
    var response;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          if (props.request) {
            _context2.next = 3;
            break;
          }
          setLoading(false);
          return _context2.abrupt("return");
        case 3:
          controller.current = new AbortController();
          setLoading(true);
          _context2.prev = 5;
          _context2.next = 8;
          return props.request();
        case 8:
          response = _context2.sent;
          setChatList(response);
          setLoading(false);
          _context2.next = 17;
          break;
        case 13:
          _context2.prev = 13;
          _context2.t0 = _context2["catch"](5);
          console.error(_context2.t0);
          setLoading(false);
        case 17:
        case "end":
          return _context2.stop();
      }
    }, _callee2, null, [[5, 13]]);
  })));
  var clearMessage = useRefFunction(function () {
    setChatList([]);
  });

  /**
   * Generates a message record.
   * @param {Partial<ChatMessage<T>>} message - The message to generate.
   */
  var genMessageRecord = useRefFunction(function (message) {
    var _props$userProfile, _initialState$userPro;
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'assistant';
    return _objectSpread({
      id: genUUID(),
      content: message,
      role: type,
      meta: ((_props$userProfile = props.userProfile) === null || _props$userProfile === void 0 ? void 0 : _props$userProfile[type]) || ((_initialState$userPro = initialState.userProfile) === null || _initialState$userPro === void 0 ? void 0 : _initialState$userPro[type]),
      createAt: Date.now(),
      updateAt: Date.now()
    }, message);
  });

  /**
   * Sends a message and updates the chat list accordingly.
   * @param {string} message - The message to send.
   * @returns {Promise<void>} - A promise that resolves when the message is sent.
   */
  var getLastLoadingMessage = useCallback(function () {
    return chatListRef.current[chatListRef.current.length - 1];
  }, [chatListRef]);
  var sendMessage = useRefFunction( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(message) {
      var userMessage, loadingMessage, _props$sendMessageReq, res, _loadingMessage, _props$transformToCha3, updatedMessage, transformMessage;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            controller.current = new AbortController();
            userMessage = genMessageRecord(typeof message === 'string' ? {
              content: message
            } : _objectSpread(_objectSpread({}, message), {}, {
              content: message.content
            }), 'user');
            chatList.push(userMessage);
            setChatList(_toConsumableArray(chatList));
            if (props !== null && props !== void 0 && props.sendMessageRequest) {
              _context6.next = 6;
              break;
            }
            return _context6.abrupt("return");
          case 6:
            setIsLoadingMessage(true);
            loadingMessage = genMessageRecord({
              content: LOADING_FLAT
            }, 'assistant');
            chatList.push(loadingMessage);
            setChatList(_toConsumableArray(chatList));
            _context6.prev = 10;
            _context6.next = 13;
            return Promise.race([(_props$sendMessageReq = props.sendMessageRequest) === null || _props$sendMessageReq === void 0 ? void 0 : _props$sendMessageReq.call(props, [chatList[chatList.length - 2]]), new Promise(function (_, reject) {
              controller.current.signal.addEventListener('abort', function () {
                reject();
              });
            })]);
          case 13:
            res = _context6.sent;
            if (!(res instanceof Response)) {
              _context6.next = 19;
              break;
            }
            _context6.next = 17;
            return processSSE(res, {
              signal: controller.current.signal,
              onFinish: function () {
                var _onFinish = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
                  var message;
                  return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                    while (1) switch (_context3.prev = _context3.next) {
                      case 0:
                        message = getLastLoadingMessage();
                        if (message) {
                          _context3.next = 3;
                          break;
                        }
                        return _context3.abrupt("return");
                      case 3:
                        setChatList(function (prev) {
                          message.isFinished = true;
                          return _toConsumableArray(prev);
                        });
                        setIsLoadingMessage(false);
                      case 5:
                      case "end":
                        return _context3.stop();
                    }
                  }, _callee3);
                }));
                function onFinish() {
                  return _onFinish.apply(this, arguments);
                }
                return onFinish;
              }(),
              onMessageHandle: function () {
                var _onMessageHandle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(text, res, type) {
                  var _props$transformToCha;
                  var loadingMessage, content, updatedMessage, transformMessage;
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        loadingMessage = getLastLoadingMessage();
                        if (loadingMessage) {
                          _context4.next = 3;
                          break;
                        }
                        return _context4.abrupt("return");
                      case 3:
                        if (!(type === 'done' || controller.current.signal.aborted)) {
                          _context4.next = 8;
                          break;
                        }
                        loadingMessage.isFinished = true;
                        setChatList(function (prev) {
                          return _toConsumableArray(prev);
                        });
                        setIsLoadingMessage(false);
                        return _context4.abrupt("return");
                      case 8:
                        content = loadingMessage.content === LOADING_FLAT ? text : loadingMessage.content + text;
                        updatedMessage = _objectSpread(_objectSpread({}, loadingMessage), {}, {
                          updateAt: Date.now(),
                          originContent: text,
                          isFinished: false,
                          content: content
                        });
                        _context4.next = 12;
                        return (_props$transformToCha = props.transformToChatMessage) === null || _props$transformToCha === void 0 ? void 0 : _props$transformToCha.call(props, updatedMessage, {
                          preContent: loadingMessage.content === LOADING_FLAT ? '' : loadingMessage.content,
                          currentContent: text
                        });
                      case 12:
                        transformMessage = _context4.sent;
                        setChatList(function (prev) {
                          var newList = _toConsumableArray(prev);
                          newList[newList.length - 1] = transformMessage || updatedMessage;
                          return newList;
                        });
                      case 14:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }));
                function onMessageHandle(_x3, _x4, _x5) {
                  return _onMessageHandle.apply(this, arguments);
                }
                return onMessageHandle;
              }(),
              onErrorHandle: function () {
                var _onErrorHandle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(error) {
                  var loadingMessage, _props$transformToCha2, content, errorMessage, transformMessage;
                  return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                    while (1) switch (_context5.prev = _context5.next) {
                      case 0:
                        loadingMessage = getLastLoadingMessage();
                        if (!loadingMessage) {
                          _context5.next = 8;
                          break;
                        }
                        content = error.message;
                        errorMessage = _objectSpread(_objectSpread({}, loadingMessage), {}, {
                          content: content,
                          originContent: content,
                          updateAt: Date.now(),
                          isFinished: true
                        });
                        _context5.next = 6;
                        return (_props$transformToCha2 = props.transformToChatMessage) === null || _props$transformToCha2 === void 0 ? void 0 : _props$transformToCha2.call(props, errorMessage, {
                          preContent: loadingMessage.content,
                          currentContent: content
                        });
                      case 6:
                        transformMessage = _context5.sent;
                        setChatList(function (prev) {
                          return [].concat(_toConsumableArray(prev), [transformMessage || errorMessage]);
                        });
                      case 8:
                        setIsLoadingMessage(false);
                      case 9:
                      case "end":
                        return _context5.stop();
                    }
                  }, _callee5);
                }));
                function onErrorHandle(_x6) {
                  return _onErrorHandle.apply(this, arguments);
                }
                return onErrorHandle;
              }()
            });
          case 17:
            _context6.next = 27;
            break;
          case 19:
            _loadingMessage = getLastLoadingMessage();
            if (!_loadingMessage) {
              _context6.next = 26;
              break;
            }
            updatedMessage = _objectSpread(_objectSpread(_objectSpread({}, _loadingMessage), res), {}, {
              updateAt: Date.now()
            });
            _context6.next = 24;
            return (_props$transformToCha3 = props.transformToChatMessage) === null || _props$transformToCha3 === void 0 ? void 0 : _props$transformToCha3.call(props, updatedMessage, {
              preContent: _loadingMessage.content,
              currentContent: updatedMessage.originContent
            });
          case 24:
            transformMessage = _context6.sent;
            setChatList(function (prev) {
              return [].concat(_toConsumableArray(prev), [transformMessage || updatedMessage]);
            });
          case 26:
            setIsLoadingMessage(false);
          case 27:
            _context6.next = 32;
            break;
          case 29:
            _context6.prev = 29;
            _context6.t0 = _context6["catch"](10);
            console.error('Error sending message:', _context6.t0);
          case 32:
          case "end":
            return _context6.stop();
        }
      }, _callee6, null, [[10, 29]]);
    }));
    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }());

  /**
   * Stops the generation of messages.
   */
  var stopGenerateMessage = useRefFunction(function () {
    var _controller$current$a, _controller$current;
    (_controller$current$a = (_controller$current = controller.current).abort) === null || _controller$current$a === void 0 || _controller$current$a.call(_controller$current);
  });
  useEffect(function () {
    fetchChatList();
  }, []);
  var helloMessageList = useMemo(function () {
    var _props$userProfile2;
    return [{
      id: genUUID(),
      content: props.helloMessage,
      role: 'bot',
      createAt: Date.now(),
      updateAt: Date.now(),
      meta: ((_props$userProfile2 = props.userProfile) === null || _props$userProfile2 === void 0 ? void 0 : _props$userProfile2.assistant) || initialState.userProfile.assistant
    }];
  }, []);
  return {
    chatList: chatList.length > 0 ? chatList : helloMessageList,
    loading: loading,
    isLoadingMessage: isLoadingMessage,
    stopGenerateMessage: stopGenerateMessage,
    setMessageItem: setMessageItem,
    clearMessage: clearMessage,
    sendMessage: sendMessage,
    genMessageRecord: genMessageRecord
  };
};